import subprocess
from pathlib import Path
import json
import logging

def run_ctags(repo_path_str):
    """
    Run ctags on the specified repository path to generate a JSON index of code definitions.
    
    Args:
        repo_path_str (str): Path to the repository to index
        
    Returns:
        bool: True if ctags ran successfully, False otherwise
    """
    # Convert string path to Path object
    repo_path = Path(repo_path_str)
    
    # Define the output tags file path
    tags_file = Path("./ctags_index.tags")
    
    # Construct the ctags command
    # Adjust executable name if needed - might be 'ctags', 'exuberant-ctags', 'universal-ctags', etc.
    command = [
        "ctags",  # Replace with the correct executable name for your system
        "--fields=+neKPSZ",  # Include line number, end line, kind, signature, scope
        "--output-format=json",  # Output in JSON format for easier parsing
        "-R",  # Recursively process directories
        f"-f{tags_file.absolute()}",  # Output file path
        str(repo_path)  # Path to repository
    ]
    
    # Additional options that might be useful:
    # "--languages=Python,JavaScript,Java,C,C++",  # Limit to specific languages
    # "--exclude=node_modules",  # Exclude specific directories
    # "--exclude=*.min.js",  # Exclude minified files
    
    try:
        # Run the command
        result = subprocess.run(
            command, 
            capture_output=True, 
            text=True, 
            check=False,  # Don't raise exceptions on non-zero exit
            cwd=repo_path_str
        )
        
        # Check the return code
        if result.returncode != 0:
            logging.error(f"ctags failed with return code {result.returncode}")
            logging.error(f"stdout: {result.stdout}")
            logging.error(f"stderr: {result.stderr}")
            return False
        
        logging.info(f"ctags successfully generated tags file at {tags_file.absolute()}")
        return True
    
    except Exception as e:
        logging.error(f"Error running ctags: {str(e)}")
        return False

def parse_ctags_json(tags_file_path="./ctags_index.tags"):
    """
    Parse the JSON tags file generated by ctags into a structured dictionary.
    
    Args:
        tags_file_path (str): Path to the ctags JSON file
        
    Returns:
        dict: A dictionary of definitions, where keys are symbol names and values are
              lists of occurrences with path, line, kind, and signature information
    """
    # Initialize the definitions dictionary
    definitions = {}
    
    # Check if the tags file exists
    tags_file = Path(tags_file_path)
    if not tags_file.exists():
        logging.warning(f"Tags file {tags_file_path} does not exist")
        return definitions
    
    # Read and parse the tags file line by line
    try:
        with open(tags_file, 'r') as f:
            for line in f:
                try:
                    # Parse the JSON line
                    tag = json.loads(line.strip())
                    
                    # Skip if no name
                    if 'name' not in tag:
                        continue
                    
                    name = tag['name']
                    
                    # Extract the relevant fields
                    # Note: field names might vary depending on ctags version and configuration
                    path = tag.get('path', '')
                    
                    # Try different field names for line number
                    line_num = tag.get('line', tag.get('lineNumber', tag.get('scopeLine')))
                    if line_num is None and 'pattern' in tag:
                        # Extract line number from pattern if available
                        # This is a fallback and might not always work correctly
                        pattern = tag['pattern']
                        if pattern.startswith('/^') and pattern.endswith('$/'):
                            # Pattern typically looks like '/^    def function_name():$/''
                            pass  # Would need regex to extract line number, but ctags should provide line number
                    
                    kind = tag.get('kind', '')
                    signature = tag.get('signature', '')
                    
                    # Initialize list for this name if not already present
                    if name not in definitions:
                        definitions[name] = []
                    
                    # Add this definition to the list
                    definitions[name].append({
                        "path": path,
                        "line": line_num,
                        "kind": kind,
                        "signature": signature
                    })
                    
                except json.JSONDecodeError:
                    # Skip lines that aren't valid JSON
                    continue
                except Exception as e:
                    logging.warning(f"Error parsing tag: {str(e)}")
                    continue
        
        return definitions
    
    except Exception as e:
        logging.error(f"Error reading tags file: {str(e)}")
        return definitions

if __name__ == "__main__":
    # Example usage
    import argparse
    
    parser = argparse.ArgumentParser(description="Generate ctags index for a repository")
    parser.add_argument("repo_path", help="Path to the repository")
    
    args = parser.parse_args()
    
    # Run ctags
    success = run_ctags(args.repo_path)
    
    if success:
        # Parse the generated tags file
        definitions = parse_ctags_json()
        
        # Print some statistics
        num_symbols = len(definitions)
        total_definitions = sum(len(defs) for defs in definitions.values())
        
        print(f"Successfully indexed {num_symbols} unique symbols with {total_definitions} total definitions.")
        
        # Optionally print some examples
        print("\nSample of indexed symbols:")
        count = 0
        for name, defs in definitions.items():
            if count >= 5:
                break
            print(f"{name}: {len(defs)} definition(s)")
            for def_info in defs[:2]:  # Show at most 2 definitions per symbol
                print(f"  - {def_info['path']}:{def_info['line']} ({def_info['kind']})")
            count += 1
    else:
        print("Failed to run ctags. Make sure ctags is installed and available in your PATH.") 